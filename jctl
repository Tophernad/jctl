#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Interact with Jamf Pro Server

Examples:

# List app policies
$> pctl policy list

"""


__author__ = 'James Reynolds, Sam Forester'
__email__ = 'reynolds@biology.utah.edu, sam.forester@utah.edu'
__copyright__ = 'Copyright (c) 2020 University of Utah, Marriott Library & School of Biological Sciences'
__license__ = 'MIT'
__version__ = "1.1.0"
min_jamf_version = "0.6.0"


from pprint import pprint
import argparse
import jamf
import json
import logging
import pathlib
import re
import sys
import time

#import jamf.admin
#from jamf.package import Package
#import jamf.config


class Parser:
    def __init__(self):
        valid_jamf_records = [x.lower() for x in jamf.records.valid_records()]
        self.parser = argparse.ArgumentParser()
        # https://docs.python.org/3/library/argparse.html
        self.parser.add_argument('-C', '--config', help='path to config file')
        self.parser.add_argument('-v', '--version', action='store_true',
            help='print version and exit')
        self.parser.add_argument('record', metavar='RECORD',
            choices=valid_jamf_records, help='Valid Jamf Records are: '+
            ', '.join(valid_jamf_records))
        self.parser.add_argument('-x', '--exact', nargs='*',
            help='Search for exact name matches')
        self.parser.add_argument('-r', '--regex', nargs='*',
            help='Search for regular expression matches')
        self.parser.add_argument('-i', '--id', nargs='*',
            help='Search for id matches')
#         self.parser.add_argument('-s', '--searchpath', action='append',
#             help='Search for a path (e.g. \'-p general,id==152\'')
        # Print options
        self.parser.add_argument('-l', '--long', action='store_true',
            help='List long format')
        self.parser.add_argument('-j', '--json', action='store_true',
            help='Print json (for pretty pipe to `prettier --parser json`)')
        self.parser.add_argument('--quiet-as-a-mouse', action='store_true',
            help='Don\'t print anything')
        # Path
#         self.parser.add_argument('-p', '--path', action='append',
#             help='Print out path (e.g. \'-p general -p serial_number\')')

        # Actions
#         self.parser.add_argument('-d', '--delete', action='store_true',
#             help='Delete jamf record')
#         self.parser.add_argument('--use-the-force-luke', action='store_true',
#             help="Don't ask to delete. DANGER! This can delete everything!")
#         self.parser.add_argument('--andele-andele', action='store_true',
#             help="Don't pause 3 seconds when updating or deleting without "
#                  "confirmation. DANGER! This can delete everything FAST!")
#         self.parser.add_argument('-u', '--update', action='append',
#             help='Update jamf record (e.g. \'-u general={} -u name=123\')')

    def parse(self, argv):
        """
        :param argv:    list of arguments to parse
        :returns:       argparse.NameSpace object
        """
        args = self.parser.parse_args(argv)
        if args.quiet_as_a_mouse:
            if args.json:
                print("Can't print json if quiet...")
                _exit()
            if args.long:
                print("Can't print long if quiet...")
                _exit()
        return args


def check_version():
    try:
        jamf_first, jamf_second, jamf_third = jamf.__version__.split(".")
        min_first, min_second, min_third = min_jamf_version.split(".")

        if ( int(jamf_first) <= int(min_first) and
             int(jamf_second) <= int(min_second) and
             int(jamf_third) < int(min_third)):
             print(f"Your Version is: {jamf.__version__}, you need at least "
                   f"version {min_jamf_version} to run this version of jctl.")
             _exit()

    except AttributeError:
             print(f"Your Version is below 0.4.2, you need at least version "
                   f"{min_jamf_version} to run this version of jctl.")
             _exit()


def confirm(_message):
    """
    Ask user to enter Y or N (case-insensitive).
    :return: True if the answer is Y.
    :rtype: bool
    """
    answer = ""
    while answer not in ["y", "n"]:
        answer = input(_message).lower()
    return answer == "y"

def main(argv):
    # THERE ARE EXITS THROUGHOUT
    logger = logging.getLogger(__name__)
    timmy = Parser()
    args = timmy.parse(argv)
    logger.debug(f"args: {args!r}")
    if args.version:
        print("jctl "+__version__)
        print("python_jamf "+jamf.__version__+ " ("+min_jamf_version+" required)")
        _exit()
    check_version()
    if args.config:
        api = jamf.API(config_path=args.config)
    else:
        api = jamf.API()

    # Get the main class
    records = jamf.records.class_name(args.record, case_sensitive=False)()

    # Filter records
    results = []
    if args.regex or args.exact or args.id:
        temps = []
        if args.regex:
            for regex in args.regex:
                temps = temps + [records.recordsWithRegex(regex)]
        if args.exact:
            for name in args.exact:
                temps = temps + [records.recordWithName(name)]
        if args.id:
            for id in args.id:
                try:
                    id = int(id)
                except ValueError:
                    print(f"ID must be a number: {id}")
                    exit(1)
                temps = temps + [records.recordWithId(id)]

        # Filter
        for temp in temps:
            if temp:
                results = results + [temp]

    else:
        results = records

    if results:
        results = sorted(results)

    # Print feedback
    if args.json and not args.quiet_as_a_mouse:
        json_output = "["
    for result in results:
            if not args.quiet_as_a_mouse:

                if args.json:
                    print(json_output)
                    json_output = "  ["
                if False:
                    pass
                elif args.long:
                    if args.json:
                        json_output += json.dumps(result.data())+","
                    else:
                        pprint(result.data())
                else:
                    if args.json:
                        json_output += json.dumps(result.name)
                    else:
                        print(result)
                if args.json:
                    json_output += "],"

    if not args.quiet_as_a_mouse:
        if args.json:
            json_output = json_output[:-1] # Remove the last comma
            print(json_output)
            print("]")
        else:
            print("Count: "+str(len(results)))


if __name__ == '__main__':
    fmt = '%(asctime)s: %(levelname)8s: %(name)s - %(funcName)s(): %(message)s'
    logging.basicConfig(level=logging.INFO, format=fmt)
    try:
        main(sys.argv[1:])
    except KeyboardInterrupt:
            _exit(1)